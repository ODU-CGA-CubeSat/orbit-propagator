# Orbit Propagator

C library for performing orbit propagation, based on Vinti6 algorithm.

## Cloning the repo

Clone the [Orbit Propagator](https://github.com/odu-cga-cubesat/orbit-propagator.git) repo. Don't forget to use `--recurse-submodules` flag, or else you won't pull down some of the code needed to run unit tests.

```bash
git clone --recurse-submodules git@github.com:ODU-CGA-CubeSat/orbit-propagator.git
cd orbit-propagator
```

Note: If you accidentally cloned without using `--recurse-submodules`, you can run `git submodule update --init --recursive` to pull down submodules needed to run unit tests.

## Build with CMake

This builds the main executable written in C

```bash
mkdir build
cd build
cmake ..
make
```

## State Vector Example

The main executable, `orbit-propagator`, as well as the simulation, `vinti_sim.m`, take as input/output an [ECI](https://en.wikipedia.org/wiki/Earth-centered_inertial) state vector which gives position and velocity in cartesian coordinates.
```
x  =      2328.9659400000   km
y  =     -5995.2160000000   km
z  =      1719.9789400000   km
xd =         2.9111011300   km/s
yd =         -.9816405300   km/s
zd =        -7.0904992200   km/s
```

## Usage

### Running main executable

Create an `inputStateVect.txt` in the `build/` directory using ECI coordinates and units of km, km/s, example below

```
4063.75
0
5134.54
0
7.826
0
```

In the `build/` directory, run main executable

```bash
./orbit-propagator
```

This outputs a new state vector to `outputStateVect.txt` (ECI cartesian and mean elements)

### Running unit tests

In the `build/` directory, run

```bash
ctest -V
```

### Running Octave Simulation

After running the build commands, you may run the the Octave orbit simulation, `vinti_sim.m`.

Create an input text file in the `orbit-propagator` project directory using ECI coordinates in km, km/s.

Example below using initial condition for mission generated by STK:

`STK_initialCond.txt`

```
-5877.6
428.24
3051.4
-2.991
-5.0497
-5.0231
```

Add GPS data in .csv file format to allow simulation to ping GPS for state vector.

Data can be simulated or real but it must vary with a timestep of 60 s.

In Octave, navigate to `orbit-propagator` and from "Command Window" (in Octave) call:

`[x_ECI, orbital_lifetime_hrs] = vinti_sim(max_simulation_time_hrs, 'inputFileName', 'dragCondition', SatMass, 'GPSFileName', GPS_period_min, 'OutputFileName')`

Where,

Inputs:  
- `max_simulation_time_hrs` is the numeric value of the max orbital time for which propogation is desired*;
- `inputFileName` is the string value of the input file created above;
- `dragCondition` is the string value describing whether the cubeSat is: `tumbling`, `front`, `boom_front`, `boom_tumbling`; and
- `SatMass` is the numeric value of the CubeSat mass (e.g., 4.5 kg)
- 'GPSFileName' is the string value of the .csv file containing GPS ephemeris data (time and state vector)
-  GPS_period_min is the numeric value of how often the satellite will ping the GPS in minutes
- 'OutputFileName' is the string value of the .csv file for ephemeris data

Outputs:
- `x_ECI` gives propogated TLE data in ECI coordinates; and
- `orbital_lifetime_hrs` is the satellite lifetime based on reaching a termination altitude of 65 km*

  \* Note: orbital_lifetime_hrs will always be less than or equal to max_simulation_time_hrs

Example usage:

`[stateVector,orbital_lifetime_hrs] = vinti_sim(2,"STK_initialCond.txt","tumbling",4,"HPOP_cD2_2_J2000_Position.csv",30,"Vinti_ephemeris_tumbling_4kg")`
